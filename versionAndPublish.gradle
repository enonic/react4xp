import groovy.json.JsonSlurper

// GROUPWISE AUTOMATED VERSION + PUBLISH
// Automates main- and subpackages version bumping and NPM publishing of updated packages, using lerna and some custom logic.
//
// Versions are autogenerated, based on 'feat:' and 'BREAKING CHANGE' git commit messages (see https://www.conventionalcommits.org/en/v1.0.0/)
//
// Why? Lerna updates versions and dependents, but internal dependencies between the packages means that dependents need
// to update their package-lock AFTER their dependencies have been released with new lerna-generated versions.
//
// So [ lerna-version --> publish --> post-publish-git ] happens in 3 stages (levels), to ensure that package-locks are
// rebuilt with existing/published package versions:
//   - Level 1: The regions + constants packages are released FIRST, since other packages depend on them,
//   - Level 3: The react4xp package is released LAST, since it depends on all the other packages,
//   - Level 2: All other packages are published in between.
// Before all this, npmLinking, building and tests are run.
// And finally, temporary (prerelease) tags created by lerna are wiped, based on PRERELEASE_ID
//
// Usage: gradlew versionAndPublish
// CLI options:
//   -Pmessage=... (describes the entire multi-level publication)
//   -Pdry (dry-run)
//
// TODO: less abomination, more DRY.


def PRERELEASE_ID = "prereleasetmp"

def msg = (project.hasProperty("message")) ? project.property("message") : "publish"

def lernaVersionCommonCmd = [
  'lerna', 'version',
  '--conventional-commits',
  '--exact',
  '--no-push',
  '--include-merged-tags',
  '--no-changelog'
]
task versionLevel1(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-prerelease=react4xp-build-components,react4xp-runtime-client,react4xp-runtime-externals,react4xp-runtime-nashornpolyfills,react4xp',
    '--preid', "$PRERELEASE_ID",
    '-m', "'chore(release lvl 1): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  standardInput = System.in
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}
task versionLevel2(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-graduate=react4xp-build-components,react4xp-runtime-client,react4xp-runtime-externals,react4xp-runtime-nashornpolyfills',
    '--conventional-prerelease=react4xp',
    '--preid', "$PRERELEASE_ID",
    '-m', "'chore(release lvl 2): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  standardInput = System.in
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}
task versionLevel3(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-graduate=react4xp',
    '--preid', "$PRERELEASE_ID",
    '-m', "'chore(release lvl 3): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  standardInput = System.in
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}



////////////////////////

task wipePrereleaseTagsRemote(type: Exec) {
  commandLine 'git', 'push', '--delete', 'origin', '$(git tag -l "*' + PRERELEASE_ID + '*")'
  enabled = !project.hasProperty("dry")
}
task wipePrereleaseTagsLocal(type: Exec) {
  commandLine 'git', 'tag', '-d', '$(git tag -l "*' + PRERELEASE_ID + '*")'
  enabled = !project.hasProperty("dry")
  dependsOn wipePrereleaseTagsRemote
}


task npmClean1(type: NpmTask) {
  args = ['run', 'cleanNpm']
  enabled = !project.hasProperty("dry")
}
task npmClean2(type: NpmTask) {
  args = ['run', 'cleanNpm']
  enabled = !project.hasProperty("dry")
}
task npmClean3(type: NpmTask) {
  args = ['run', 'cleanNpm']
  enabled = !project.hasProperty("dry")
  dependsOn wipePrereleaseTagsLocal
}


task npmInstall1(type: NpmTask) {
  args = ['run', 'npmInstall']
  enabled = !project.hasProperty("dry")
  dependsOn npmClean1
}
task npmInstall2(type: NpmTask) {
  args = ['run', 'npmInstall']
  enabled = !project.hasProperty("dry")
  dependsOn npmClean2
}
task npmInstall3(type: NpmTask) {
  args = ['run', 'npmInstall']
  enabled = !project.hasProperty("dry")
  dependsOn npmClean3
}


task gitAdd1(type: Exec) {
  commandLine 'git', 'add', '.', '--all'
  enabled = !project.hasProperty("dry")
  dependsOn npmInstall1
}
task gitAdd2(type: Exec) {
  commandLine 'git', 'add', '.', '--all'
  enabled = !project.hasProperty("dry")
  dependsOn npmInstall2
}
task gitAdd3(type: Exec) {
  commandLine 'git', 'add', '.', '--all'
  enabled = !project.hasProperty("dry")
  dependsOn npmInstall3
}


task gitCommit1(type: Exec) {
  commandLine 'git', 'commit', "-m'Post level1 release: update package-locks'"
  enabled = !project.hasProperty("dry")
  dependsOn gitAdd1
}
task gitCommit2(type: Exec) {
  commandLine 'git', 'commit', "-m'Post level2 release: update package-locks'"
  enabled = !project.hasProperty("dry")
  dependsOn gitAdd2
}
task gitCommit3(type: Exec) {
  commandLine 'git', 'commit', "-m'Post level3 release: update package-locks'"
  enabled = !project.hasProperty("dry")
  dependsOn gitAdd3
}


task gitPush1(type: Exec) {
  commandLine 'git', 'push'
  enabled = !project.hasProperty("dry")
  dependsOn gitCommit1
}
task gitPush2(type: Exec) {
  commandLine 'git', 'push'
  enabled = !project.hasProperty("dry")
  dependsOn gitCommit2
}
task gitPush3(type: Exec) {
  commandLine 'git', 'push'
  enabled = !project.hasProperty("dry")
  dependsOn gitCommit3
}


task postLevel1() {
  dependsOn gitPush1
}

task postLevel2() {
  dependsOn gitPush2
}

task postLevel3() {
  dependsOn gitPush3
}


task versionAndPublish(){
  group('Publish')
  description('Automated full-project version bumping and NPM publishing of updated packages and their dependents. See versionAndPublish.gradle')
}

def getCurrentlyReleasedVersion(packageName) {
  def sout = new StringBuilder(), serr = new StringBuilder()
  def checkVersionCmd = "npm view $packageName version"
  println checkVersionCmd
  def proc = checkVersionCmd.execute()
  proc.consumeProcessOutput(sout, serr)
  proc.waitForOrKill(10000)
  println "out> $sout"
  println "err> $serr"
  // TODO: Verify returned version format.
  // TODO: Handle errors.
  // TODO: Return parsed version
  return false
}

def PRERELEASE_PATTERN = ~".*$PRERELEASE_ID.*"
def shouldPublish(PACKAGE_JSON) {
  if (PACKAGE_JSON.version ==~ PRERELEASE_PATTERN) {
    println "Skipping."
    return false
  }

  def latestVersion = getCurrentlyReleasedVersion(PACKAGE_JSON.name)
  // TODO: Compare latestVersion (from NPM) with PACKAGE_JSON.version. If lower, return true. If equal, return false.
  // TODO: If latestVersion is higher throw error? If format weirdness, throw error?
  return false
  // println "    ${project.name}@${PACKAGE_JSON.version}: enable publish (i.e. '$PR ERELEASE_ID' wasn't found in version)? $enablePublish"
}


def handleNpmPublishError(sout, serr) {
  throw GradleException("Npm Publish error handling and detection are not implemented.")
}

def NPM_PUBLISH_CMD = "npm publish${(project.hasProperty("dry")) ? "" : ' --dry-run'}"

configure(subprojects.findAll {!project.ext.SUBPROJS_TO_IGNORE.contains(it.name)}) {



  // Set up 3 groups (levels) of publish, which must happen in that order.
  // Also disable publish for each package that has the prerelease ID in the version string:



  task publishLevel1() {
    enabled = false
    doLast {
      def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
      println "Level 1: $NPM_PUBLISH_CMD ${project.name}@${PACKAGE_JSON.version}?"

      if (shouldPublish(PACKAGE_JSON)) {
        def sout = new StringBuilder(), serr = new StringBuilder()
        def proc = NPM_PUBLISH_CMD.execute()
        proc.consumeProcessOutput(sout, serr)
        proc.waitForOrKill(10000)
        handleNpmPublishError(sout, serr)
      }
    }
  }
  task publishLevel2() {
    enabled = false
    doLast {
      def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
      println "Level 2: $NPM_PUBLISH_CMD ${project.name}@${PACKAGE_JSON.version}?"

      if (shouldPublish(PACKAGE_JSON)) {
        def sout = new StringBuilder(), serr = new StringBuilder()
        def proc = NPM_PUBLISH_CMD.execute()
        proc.consumeProcessOutput(sout, serr)
        proc.waitForOrKill(10000)
        handleNpmPublishError(sout, serr)
      }
    }
  }
  task publishLevel3() {
    enabled = false
    doLast {
      def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
      println "Level 1: $NPM_PUBLISH_CMD ${project.name}@${PACKAGE_JSON.version}?"

      if (shouldPublish(PACKAGE_JSON)) {
        def sout = new StringBuilder(), serr = new StringBuilder()
        def proc = NPM_PUBLISH_CMD.execute()
        proc.consumeProcessOutput(sout, serr)
        proc.waitForOrKill(10000)
        handleNpmPublishError(sout, serr)
      }
    }
  }


  // Enables/disables based on currently configured subproject's name:

  // regions and constants are released first, since other packages depend on them:
  if (project.name == "regions" || project.name == "constants") {
    publishLevel1.enabled = true

    // react4xp is released last, since it depends on all the other packages:
  } else if (project.name == "react4xp") {
    publishLevel3.enabled = true

    // All other packages are published in between:
  } else {
    publishLevel2.enabled = true
  }

  versionAndPublish.dependsOn postLevel3
  postLevel3.dependsOn publishLevel3
  publishLevel3.dependsOn versionLevel3

  versionLevel3.dependsOn postLevel2
  postLevel2.dependsOn publishLevel2
  publishLevel2.dependsOn versionLevel2

  versionLevel2.dependsOn postLevel1
  postLevel1.dependsOn publishLevel1
  publishLevel1.dependsOn versionLevel1
  versionLevel1.dependsOn build
  versionLevel1.dependsOn npmLink
  build.shouldRunAfter npmLink


  wipePrereleaseTagsRemote.mustRunAfter publishLevel3
  npmClean2.mustRunAfter publishLevel2
  npmClean1.mustRunAfter publishLevel1
}




///////////////////////////////////////////////////////////////////////////////
