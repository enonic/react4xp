import groovy.json.JsonSlurper

// GROUPWISE AUTOMATED VERSION + PUBLISH
// Automates main- and subpackages version bumping and NPM publishing of updated packages, using lerna and some custom logic.
//
// Versions are autogenerated, based on 'feat:' and 'BREAKING CHANGE' git commit messages (see https://www.conventionalcommits.org/en/v1.0.0/)
//
// Why? Lerna updates versions and dependents, but internal dependencies between the packages means that dependents need
// to update their package-lock AFTER their dependencies have been released with new lerna-generated versions.
//
// So [ lerna-version --> publish --> post-publish-git ] happens in 3 stages (levels), to ensure that package-locks are
// rebuilt with existing/published package versions:
//   - Level 1: The regions + constants packages are released FIRST, since other packages depend on them,
//   - Level 3: The react4xp package is released LAST, since it depends on all the other packages,
//   - Level 2: All other packages are published in between.
// Before all this, npmLinking, building and tests are run.
// And finally, temporary (prerelease) tags created by lerna are wiped, based on PRERELEASE_ID
//
// Usage: gradlew versionAndPublish
// CLI options:
//   -Pmessage=... (describes the entire multi-level publication)
//   -Pdry (dry-run)
//
// TODO: I can't imagine this will work in windows. Should probably fix that.
// TODO: less abomination, more DRY.


def PRERELEASE_ID = "prereleasetmp"
project.ext.SEMVER_PATTERN = ~"\\d+\\.\\d+\\.\\d+"

def msg = (project.hasProperty("message")) ? project.property("message") : "publish"

def lernaVersionCommonCmd = [
  'lerna', 'version',
  '--conventional-commits',
  '--exact',
  '--no-push',
  '--include-merged-tags',
  '--no-changelog'
]
task versionLevel1(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-prerelease=react4xp-build-components,react4xp-runtime-client,react4xp-runtime-externals,react4xp-runtime-nashornpolyfills,react4xp',
    '--preid', "$PRERELEASE_ID",
    '-m', "'chore(release lvl 1): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  standardInput = System.in
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}
task versionLevel2(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-graduate=react4xp-build-components,react4xp-runtime-client,react4xp-runtime-externals,react4xp-runtime-nashornpolyfills',
    '--preid', "$PRERELEASE_ID",
    '-m', "'chore(release lvl 2): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  standardInput = System.in
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}
task versionLevel3(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-graduate=react4xp',
    '--preid', "$PRERELEASE_ID",
    '-m', "'chore(release lvl 3): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  standardInput = System.in
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}



////////////////////////

task cleanPrereleaseTags(type: Exec) {
  commandLine './cleanTagsContaining.sh', PRERELEASE_ID
  enabled = !project.hasProperty("dry")
}


task npmClean1(type: NpmTask) {
  args = ['run', 'cleanNpm']
  enabled = !project.hasProperty("dry")
}
task npmClean2(type: NpmTask) {
  args = ['run', 'cleanNpm']
  enabled = !project.hasProperty("dry")
}
task npmClean3(type: NpmTask) {
  args = ['run', 'cleanNpm']
  enabled = !project.hasProperty("dry")
  dependsOn cleanPrereleaseTags
}


task npmInstall1(type: NpmTask) {
  args = ['run', 'npmInstall']
  enabled = !project.hasProperty("dry")
  dependsOn npmClean1
}
task npmInstall2(type: NpmTask) {
  args = ['run', 'npmInstall']
  enabled = !project.hasProperty("dry")
  dependsOn npmClean2
}
task npmInstall3(type: NpmTask) {
  args = ['run', 'npmInstall']
  enabled = !project.hasProperty("dry")
  dependsOn npmClean3
}


task gitAdd1(type: Exec) {
  commandLine 'git', 'add', '.', '--all'
  enabled = !project.hasProperty("dry")
  dependsOn npmInstall1
}
task gitAdd2(type: Exec) {
  commandLine 'git', 'add', '.', '--all'
  enabled = !project.hasProperty("dry")
  dependsOn npmInstall2
}
task gitAdd3(type: Exec) {
  commandLine 'git', 'add', '.', '--all'
  enabled = !project.hasProperty("dry")
  dependsOn npmInstall3
}


task gitCommit1(type: Exec) {
  commandLine 'git', 'commit', "-m'Post level1 release: update package-locks'"
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
  dependsOn gitAdd1
}
task gitCommit2(type: Exec) {
  commandLine 'git', 'commit', "-m'Post level2 release: update package-locks'"
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
  dependsOn gitAdd2
}
task gitCommit3(type: Exec) {
  commandLine 'git', 'commit', "-m'Post level3 release: update package-locks'"
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
  dependsOn gitAdd3
}


task gitPush1(type: Exec) {
  commandLine 'git', 'push'
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
  dependsOn gitCommit1
}
task gitPush2(type: Exec) {
  commandLine 'git', 'push'
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
  dependsOn gitCommit2
}
task gitPush3(type: Exec) {
  commandLine 'git', 'push'
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
  dependsOn gitCommit3
}


task postLevel1() {
  dependsOn gitPush1
}

task postLevel2() {
  dependsOn gitPush2
}

task postLevel3() {
  dependsOn gitPush3
}


task versionAndPublish(){
  group('Publish')
  description('Automated full-project version bumping and NPM publishing of updated packages and their dependents. See versionAndPublish.gradle')
}



def execAndGetOutput(shellCommand, workingDir, failOnStdErr) {
  def output = ""
  def errors = ""
  println shellCommand
  try {
    def sout = new StringBuilder(), serr = new StringBuilder()
    def proc = shellCommand.execute(null, new File(workingDir))
    proc.consumeProcessOutput(sout, serr)
    proc.waitForProcessOutput()
    output = "$sout".trim()
    errors = "$serr".trim()

    if (errors) {
      println "--- StdErr:"
      println "$errors"
      println "---"
      if (failOnStdErr) {
        println "Command ('$shellCommand') produced stderr - aborting script."
        throw new GradleException("Command produced stderr: $shellCommand")
      }
    }

    return output

  } catch (e) {
    println ""
    println "Command that failed: $shellCommand"
    if (output) {
      println "--- StdOut:"
      println $output
    } else {
      println "--- (no StdOut)"
    }
    if (errors) {
      println "--- StdErr:"
      println
    } else {
      println "--- (no StdErr)"
    }
    println "---"

    println "Re-throwing"
    throw new GradleException(e.message)
  }
}


def getCurrentlyReleasedVersion(packageName) {
  def output = execAndGetOutput("npm view $packageName version", ".", true)

  if (output ==~ project.ext.SEMVER_PATTERN) {
    return output
  }

  throw new GradleException("Unexpected output: non-semver string returned by NPM: '$output'")
}


def versionToNumber(verstionString) {
  def versionMatcher = verstionString =~ /(\d+)\.(\d+)\.(\d+)/
  if (!versionMatcher.matches()) {
    throw new GradleException("Version string '$verstionString' doesn't match the semver pattern 'major.minor.patch'")
  }
  def major = versionMatcher[0][1].toInteger()
  def minor = versionMatcher[0][2].toInteger()
  def patch = versionMatcher[0][3].toInteger()
  return major * 1000000 + minor * 1000 + patch
}


def shouldPublish(PACKAGE_JSON) {
  if (PACKAGE_JSON.version ==~ project.ext.SEMVER_PATTERN) {
    def latestReleasedVersion = getCurrentlyReleasedVersion(PACKAGE_JSON.name)
    if (!latestReleasedVersion) {
      return false
    }

    def latestReleaseValue = versionToNumber(latestReleasedVersion)
    def localValue = versionToNumber(PACKAGE_JSON.version)
    println "    Latest release: $latestReleasedVersion"
    println "    Local:          $PACKAGE_JSON.version"

    if (latestReleaseValue < localValue) {
      println "    Local version is ahead. Proceeding."
      return true

    } else if (latestReleaseValue == localValue) {
      println "    Local version is equal. Skipping."
      return false

    } else {
      throw new GradleException("Unexpected: local version '${PACKAGE_JSON.version}' is BEHIND latest release at NPM: '$latestReleasedVersion'. This automated script assumes local version is ahead, equal or temporary. Handle manually.")
    }

  } else {
    println "    Not publishing local ${PACKAGE_JSON.name}@${PACKAGE_JSON.version}: version is not semver (major.minor.patch)."
    return false
  }
}


def NPM_PUBLISH_CMD = "npm publish${(!project.hasProperty("dry")) ? "" : ' --dry-run'}"

configure(subprojects.findAll {!project.ext.SUBPROJS_TO_IGNORE.contains(it.name)}) {



  // Set up 3 groups (levels) of publish, which must happen in that order.
  // Also disable publish for each package that has the prerelease ID in the version string:

  task maybeSkipPublishLevel1 {
    enabled = false
    doLast {
      def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
      println "Level 1: $NPM_PUBLISH_CMD ${project.name}@${PACKAGE_JSON.version} ?"

      if (!shouldPublish(PACKAGE_JSON)) {
        publishLevel1.configure {
          enabled = false
        }
      }
    }
  }
  task publishLevel1(type: Exec) {
    enabled = false

    commandLine = NPM_PUBLISH_CMD.split(" ")
  }

  task maybeSkipPublishLevel2 {
    enabled = false
    doLast {
      def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
      println "Level 2: $NPM_PUBLISH_CMD ${project.name}@${PACKAGE_JSON.version} ?"

      if (!shouldPublish(PACKAGE_JSON)) {
        publishLevel2.configure {
          enabled = false
        }
      }
    }
  }
  task publishLevel2(type: Exec) {
    enabled = false

    commandLine = NPM_PUBLISH_CMD.split(" ")
  }

  task maybeSkipPublishLevel3 {
    enabled = false
    doLast {
      def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
      println "Level 3: $NPM_PUBLISH_CMD ${project.name}@${PACKAGE_JSON.version} ?"

      if (!shouldPublish(PACKAGE_JSON)) {
        publishLevel3.configure {
          enabled = false
        }
      }
    }
  }
  task publishLevel3(type: Exec) {
    enabled = false

    commandLine = NPM_PUBLISH_CMD.split(" ")
  }


  // Enables/disables based on currently configured subproject's name:

  // regions and constants are released first, since other packages depend on them:
  if (project.name == "regions" || project.name == "constants") {
    publishLevel1.enabled = true
    maybeSkipPublishLevel1.enabled = true

    // react4xp is released last, since it depends on all the other packages:
  } else if (project.name == "react4xp") {
    publishLevel3.enabled = true
    maybeSkipPublishLevel3.enabled = true

    // All other packages are published in between:
  } else {
    publishLevel2.enabled = true
    maybeSkipPublishLevel2.enabled = true
  }

  versionAndPublish.dependsOn postLevel3
  postLevel3.dependsOn publishLevel3
  publishLevel3.dependsOn maybeSkipPublishLevel3
  maybeSkipPublishLevel3.dependsOn versionLevel3

  versionLevel3.dependsOn postLevel2
  postLevel2.dependsOn publishLevel2
  publishLevel2.dependsOn maybeSkipPublishLevel2
  maybeSkipPublishLevel2.dependsOn versionLevel2

  versionLevel2.dependsOn postLevel1
  postLevel1.dependsOn publishLevel1
  publishLevel1.dependsOn maybeSkipPublishLevel1
  maybeSkipPublishLevel1.dependsOn versionLevel1
  versionLevel1.dependsOn build
  versionLevel1.dependsOn npmLink
  build.shouldRunAfter npmLink


  cleanPrereleaseTags.mustRunAfter publishLevel3
  npmClean2.mustRunAfter publishLevel2
  npmClean1.mustRunAfter publishLevel1
}




///////////////////////////////////////////////////////////////////////////////
