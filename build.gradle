import groovy.json.JsonSlurper

/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds
 */

plugins {
  // id "com.enonic.xp.app" version "2.0.0"
  id "com.moowork.node" version "1.3.1"
}

allprojects {
  repositories {
    mavenLocal()
    jcenter()
  }
}


/*app {
  systemVersion = "${xpVersion}"
}*/

def ignoreSubprojectDirs = [
        'packages'
]
configure(subprojects.findAll {!ignoreSubprojectDirs.contains(it.name)}) {
  apply plugin: "com.moowork.node" // version "1.3.1"

  task cleanNpm(type: Delete) {
    delete 'node_modules'
  }


  def slash = File.separator
  project.ext.PROJDIR = "${project.buildDir.toString()}${slash}${slash}${slash}".replace("${slash}build${slash}${slash}", '')

  def markerName = "${project.ext.PROJDIR}node_modules${slash}react4xp${slash}npmInstalled.marker"
  def linkMarkerName = "${project.ext.PROJDIR}node_modules${slash}react4xp${slash}npmLinked.marker"

  task nsiInstall(type:NpmTask) {
    args=['run', 'nsi:install']
    doLast {
      def marker = new File(linkMarkerName)
      new File(marker.getParent()).mkdirs()
      marker.text = """
Marker file, indicating that node_module is locally linked - faster than traversing the entire node_modules tree for changes.
"""
      println "Created: $linkMarkerName"
    }
  }
  nsiInstall.inputs.files('package.json', 'package-lock.json')
  nsiInstall.outputs.file('package-lock.json')
  nsiInstall.outputs.file file(linkMarkerName)

  if (new File(linkMarkerName).exists()) {
    println "$linkMarkerName found!"
    npmInstall.enabled = false
    npmInstall.dependsOn nsiInstall

  } else {
    // println "$linkMarkerName not found."
    npmInstall.enabled = true
    npmInstall.inputs.files('package.json', 'package-lock.json')
    npmInstall.outputs.file('package-lock.json')
    npmInstall.outputs.file file(markerName)
    npmInstall.doLast {
      def marker = new File(markerName)
      new File(marker.getParent()).mkdirs()
      marker.text = """
Marker file, indicating that the npmInstall gradle task has been run in this subproject - faster than traversing the entire node_modules tree for changes.
"""
    }
  }


  task cleanBuilt(type: Delete) {}
  task npmClean(type: Delete) {
    delete 'node_modules'
  }

  task compileJS(type: NpmTask) {}
  compileJS.inputs.file('package.json')
  compileJS.inputs.dir('src')
  compileJS.dependsOn ":packages:${project.name}:npmInstall"


  task build {}
  build.dependsOn ":packages:${project.name}:compileJS"

  task lint(type: NpmTask) {
    args=['run', 'lint']
  }
  lint.inputs.file('package.json')
  lint.inputs.dir('src')
  lint.outputs.dir('src')
  lint.dependsOn ":packages:${project.name}:npmInstall"
  build.shouldRunAfter ":packages:${project.name}:lint"


  task npmLink(type: NpmTask) {
    args=['link']
    doLast {
      def marker = new File(linkMarkerName)
      new File(marker.getParent()).mkdirs()
      marker.text = """
Marker file, indicating that node_module is locally linked - faster than traversing the entire node_modules tree for changes.
"""
      println "Created: $linkMarkerName"
    }
  }
  npmLink.dependsOn lint


  task test(type: NpmTask) {}
  test.inputs.files('package.json')
  test.inputs.dir('src')
  test.inputs.dir('test')
  test.dependsOn ":packages:${project.name}:npmClean"
  test.dependsOn ":packages:${project.name}:npmInstall"
  test.dependsOn ":packages:${project.name}:lint"
  test.dependsOn ":packages:${project.name}:npmLink"
  test.dependsOn build
  npmInstall.shouldRunAfter npmClean
  lint.shouldRunAfter npmInstall
  npmLink.shouldRunAfter lint
  build.shouldRunAfter npmLink
}

/*dependencies {
  include project(":packages:constants")
  include project(":packages:buildcomponents")
}*/

def slash = File.separator
def markerName = ".${slash}node_modules${slash}react4xp${slash}npmInstalled.txt"
npmInstall.inputs.files('package.json', 'package-lock.json')
npmInstall.outputs.file('package-lock.json')
npmInstall.outputs.file file(markerName)
npmInstall.doLast {
  def marker = new File(markerName)
  new File(marker.getParent()).mkdirs()
  marker.text = """
Marker file, indicating that the npmInstall gradle task has been run in the root project - faster than traversing the entire node_modules tree for changes.
"""
}




////////////////////////////////////////////////////

// GROUPWISE AUTOMATED VERSION + PUBLISH
// Why? Lerna updates versions and dependents, but dependents need to update their package-lock AFTER their dependencies have been released with new versions.

def PRERELEASE_ID = "prereleasetmp"

def msg = (project.hasProperty("message")) ? project.property("message") : "publish"
def lernaVersionCommonCmd = [
  'lerna', 'version',
  '--conventional-commits',
  '--exact',
  '--no-push',
  '--include-merged-tags',
  '--no-changelog'
]
task versionLevel1(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-prerelease=react4xp-build-components,react4xp-runtime-client,react4xp-runtime-externals,react4xp-runtime-nashornpolyfills,react4xp',
    '--preid', "$PRERELEASE_ID",
    '-m', "'chore(release lvl 1): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}
task versionLevel2(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-graduate=react4xp-build-components,react4xp-runtime-client,react4xp-runtime-externals,react4xp-runtime-nashornpolyfills',
    '--conventional-prerelease=react4xp',
    '--preid', "$PRERELEASE_ID",
    '-m', "'chore(release lvl 2): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}
task versionLevel3(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-graduate=react4xp',
    '--preid', "$PRERELEASE_ID",
    '-m', "'chore(release lvl 3): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}

task postLevel1(type: Exec) {
  def cmds = [
    'npm', 'run', 'cleanNpm', '&&',
    'npm', 'run', 'npmInstall', '&&',
    'git', 'add', '.', '--all', '&&',
    'git', 'commit', "-m'Post level1 release: update package-locks'", '&&',
    'git', 'push'
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}
task postLevel2(type: Exec) {
  def cmds = [
    'npm', 'run', 'cleanNpm', '&&',
    'npm', 'run', 'npmInstall', '&&',
    'git', 'add', '.', '--all', '&&',
    'git', 'commit', "-m'Post level2 release: update package-locks'", '&&',
    'git', 'push'
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}

task postLevel3(type: Exec) {
  def cmds = [
    // Remove all temporary tags with thw prerelease ID
    'git', 'push', '--delete', 'origin', "\$(git tag -l \"*$PRERELEASE_ID*\")", '&&',
    'git', 'tag', '-d', "\$(git tag -l \"*$PRERELEASE_ID*\")", '&&',

    'npm', 'run', 'cleanNpm', '&&',
    'npm', 'run', 'npmInstall', '&&',
    'git', 'add', '.', '--all', '&&',
    'git', 'commit', "-m'Post level3 release: update package-locks'", '&&',
    'git', 'push'
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}


task versionAndPublish(){}





configure(subprojects.findAll {!ignoreSubprojectDirs.contains(it.name)}) {

  def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)

  // Set up 3 groups (levels) of publish, which must happen in that order.
  // Also disable publish for each package that has the prerelease ID in the version string:

  task publishLevel1(type: NpmTask) {
    args = (!project.hasProperty("dry")) ? ['publish'] : ['publish', '--dry-run']
    enabled = false
    doFirst {
      println "Level 1: ${args.join()} ${project.name}@${PACKAGE_JSON.version}"
    }
  }
  task publishLevel2(type: NpmTask) {
    args = (!project.hasProperty("dry")) ? ['publish'] : ['publish', '--dry-run']
    enabled = false
    doFirst {
      println "Level 1: ${args.join()} ${project.name}@${PACKAGE_JSON.version}"
    }
  }
  task publishLevel3(type: NpmTask) {
    args = (!project.hasProperty("dry")) ? ['publish'] : ['publish', '--dry-run']
    enabled = false
    doFirst {
      println "Level 1: ${args.join()} ${project.name}@${PACKAGE_JSON.version}"
    }
  }

  def pattern = ~".*$PRERELEASE_ID.*"
  def enablePublish = !(PACKAGE_JSON.version ==~ pattern)
  // println "    ${project.name}@${PACKAGE_JSON.version}: enable publish (i.e. '$PRERELEASE_ID' wasn't found in version)? $enablePublish"

  // regions and constants are released first, since other packages depend on them:
  if (project.name == "regions" || project.name == "constants") {
    publishLevel1.enabled = enablePublish

    // react4xp is released last, since it depends on all the other packages:
  } else if (project.name == "react4xp") {
    publishLevel3.enabled = enablePublish

    // All other packages are published in between:
  } else {
    publishLevel2.enabled = enablePublish
  }

  versionAndPublish.dependsOn postLevel3
  postLevel3.dependsOn publishLevel3
  publishLevel3.dependsOn versionLevel3
  versionLevel3.dependsOn postLevel2
  postLevel2.dependsOn publishLevel2
  publishLevel2.dependsOn versionLevel2
  versionLevel2.dependsOn postLevel1
  postLevel1.dependsOn publishLevel1
  publishLevel1.dependsOn versionLevel1
  versionLevel1.dependsOn test
}




///////////////////////////////////////////////////////////////////////////////
